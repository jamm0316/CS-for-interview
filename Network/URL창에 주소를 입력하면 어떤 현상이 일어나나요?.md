## 🎙️ 면접답변
1. 브라우저에서 URL을 입력하면 URL을 파싱하여 프로토콜(https)과 도메인명(www.google.com), 경로(/)를 분리합니다.
2. 이후 로컬 캐시 → OS → 라우터 → DNS 순으로 도메인명과 매칭되는 IP주소를 반환합니다.
3. 그리고 해당 IP주소를 통해 클라이언트와 서버가 TCP연결을 시도하며 이 때 3-way-handshake가 일어납니다.
    HTTPS의 경우 TLS 핸드셰이크를 통해 보안 세션을 설정합니다.
4. TCP 연결이 끝나고 나면 일반적으로 GET/ HTTP/1.1 요청을 보냅니다. 이 요청에는 헤더 정보도 포함됩니다.
5. 이후 서버는 요청에 따라 HTML 문서를 생성하여 응답합니다.
6. 브라우저는 HTML을 파싱하고 CSS/JS를 별도로 요청한 뒤, 
    DOM트리, CSSOM → Render Tree → Layout → Paint → Composite 순으로 화면을 그립니다.

---

## 🔗 DNS조회 후, 왜 TCP연결을 하나요?

> TCP 연결은 클라이언트와 서버가 안전하게 데이터 통신을 하기 위한 연결 설정 과정으로 3-way 핸드셰이크라고 합니다.

### 왜 필요한가?

웹에서 서버와 클라이언트가 통신하려면, 둘 사이에 연결이 먼저 열려야함.

이걸 마치 전화연결하듯이 준비됐는지 확인하는 절차라고 보면됨.

## TCP 연결 흐름: 3-Way Handshake

브라우저가 DNS를 통해 IP를 얻은 다음, 그 IP 주소로 접속하려면 아래 3단계를 거친다.

### 1단계: 클라이언트 → 서버 (SYN)

클라이언트에서 ISN을 담아 SYN를 서버에 보낸다.

### 2단계: 서버 → 클라이언트 (SYN - ACK)

서버에서 SYN을 수신하고 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN + 1을 보낸다.

### 3단계: 클라이언트 → 서버 (ACK)

클라이언트는 다시 서버에 ISN + 1한 값이 승인번호를 담아 ACK를 서버에 보낸다.

### 연결 완료

- SYN: Synchronize
- ACK: Acknowledge
- INS: Initial Sequence Number

- 꼬리 질문
    
    ## ✅ URL 입력 후 동작 순서 (수정 없이도 좋음, 완성도 높음)
    
    > 아주 정확하고 간결하게 잘 정리했어. 실무적인 요소만 추가하면 더 좋아:
    > 
    - “브라우저가 HTTP/HTTPS 여부를 판단해 포트와 프로토콜을 설정하고,
    - IP주소는 브라우저 캐시, OS 캐시, 라우터, DNS서버 순으로 조회”
    - TCP 연결 후 HTTPS인 경우 TLS handshake 추가
    - HTML뿐만 아니라 JS, CSS, 이미지 등 추가 리소스도 병렬 요청됨
    
    ✅ 추가 가능:
    
    - **브라우저 캐시 / CDN / 프리페치 여부에 따라 HTML 요청이 생략될 수도 있음**
    - LCP, FCP 같은 웹 성능 지표와 연결하면 더 좋음
    
    ---
    
    ## ✅ Q1. HTTP vs HTTPS 차이
    
    > 너의 설명은 맞아. 다만 "TLS도 TCP 기반에서 동작한다"는 걸 조금 더 명확히 강조하면 좋아.
    > 
    
    ### 🔄 개선 예시:
    
    > HTTP와 HTTPS의 가장 큰 차이는 데이터 암호화 여부입니다.
    > 
    > 
    > HTTP는 TCP 3-way handshake로 연결 후 데이터를 **평문**으로 주고받기 때문에 중간자 공격이나 도청 위험이 있어요.
    > 
    > 반면, HTTPS는 TCP 연결 이후에 **TLS handshake** 과정을 추가로 거쳐서 데이터를 암호화하고, 위변조를 방지합니다.
    > 
    > TLS 과정에서 인증서 검증, 키 교환을 거쳐 **세션키 기반 대칭 암호화** 통신을 합니다.
    > 
    
    ✅ 꼬리 질문:
    
    - TLS에서 공개키, 개인키는 각각 어떤 역할?
    - TLS handshake 중 인증서 위조는 어떻게 방지하나요?
    
    ---
    
    ## ✅ Q2. HTML 렌더링 순서
    
    > 설명이 매우 좋고 구조적이야! 아래 한 줄만 보완하면 완벽:
    > 
    
    > JavaScript가 중간에 있으면 파싱을 멈추고 먼저 로드 → ❗실행까지 완료하고 파싱을 재개함
    > 
    
    ### ✨ 보완 예시:
    
    > JavaScript는 기본적으로 HTML 파싱을 **차단(blocking)**하기 때문에 <script> 태그가 중간에 있으면 DOM 생성이 일시 정지되고, JS가 실행까지 완료된 후에 파싱이 재개됩니다.
    > 
    
    ✅ 꼬리 질문:
    
    - `defer`, `async`를 왜 사용하는지?
    - CSS 위치(head/body)와 JS 위치가 성능에 미치는 영향은?
    
    ---
    
    ## ✅ Q3. JS 로딩 최적화
    
    > 핵심을 잘 잡았어! 다만 마지막 문장에 어순을 조금 다듬으면 전달력이 더 올라가.
    > 
    
    ### ✨ 개선 예시:
    
    > async는 JS를 HTML 파싱과 병렬로 다운로드하고, 다운로드가 끝나는 즉시 실행합니다.
    > 
    > 
    > `defer`는 **HTML 파싱이 끝난 후, 실행 순서를 보장하며 순차 실행**됩니다.
    > 
    > 그래서 `async`는 빠르지만 순서 보장이 안 되고, `defer`는 파싱 완료 후 실행되기 때문에 대부분의 스크립트에 적합합니다.
    > 
    
    ✅ 꼬리 질문:
    
    - async/defer는 외부 스크립트에만 적용되나요?
    - 왜 모듈 스크립트(`<script type="module">`)는 기본적으로 defer인가요?
    
    ---
    
    ## ✅ Q4. DOM이란?
    
    > 아주 충실하고 구조적으로 잘 설명했어.
    > 
    > 
    > "HTML을 JS로 조작 가능하게 만든 인터페이스"라는 초반 정의만 **조금 더 정리**하면 훨씬 깔끔해져.
    > 
    
    ### ✨ 개선 예시:
    
    > DOM은 HTML이나 XML 문서를 트리 구조로 표현한 객체 모델로, 자바스크립트가 문서 구조나 콘텐츠를 제어할 수 있도록 도와주는 프로그래밍 인터페이스입니다.
    > 
    > 
    > 문서는 `document` 노드를 루트로 하고, `element`, `text`, `attribute` 등의 하위 노드로 구성됩니다.
    > 
    > DOM 구조가 계층적이기 때문에 **이벤트 버블링/캡처링**, 선택자 탐색, 동적 변경이 가능해요.
    >
